//
//  ProcessGrains.c
//
//
//  Created by Hemant Sharma on 2014/06/24.
//
//  New Features (2014/11/06):
//  - Twins were implemented in a previous version.
//  - Single file reading is implemented now.
//  

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>
#include <limits.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <ctype.h>
#include <stdint.h>
#include <stdbool.h>

#define MAX_N_IDS 6000000
#define NR_MAX_IDS_PER_GRAIN 5000
#define IAColNr 20 // 20 for Internal Angle, 18 for position, 19 for omega

static inline
int**
allocMatrixInt(int nrows, int ncols)
{
    int** arr;
    int i;
    arr = malloc(nrows * sizeof(*arr));
    if (arr == NULL ) {
        return NULL;
    }
    for ( i = 0 ; i < nrows ; i++) {
        arr[i] = malloc(ncols * sizeof(*arr[i]));
        if (arr[i] == NULL ) {
            return NULL;
        }
    }
    return arr;
}

static inline
void
FreeMemMatrixInt(int **mat,int nrows)
{
    int r;
    for ( r = 0 ; r < nrows ; r++) {
        free(mat[r]);
    }
    free(mat);
}

static inline
double**
allocMatrix(int nrows, int ncols)
{
    double** arr;
    int i;
    arr = malloc(nrows * sizeof(*arr));
    if (arr == NULL ) {
        return NULL;
    }
    for ( i = 0 ; i < nrows ; i++) {
        arr[i] = malloc(ncols * sizeof(*arr[i]));
        if (arr[i] == NULL ) {
            return NULL;
        }
    }
    return arr;
}

static inline
void
FreeMemMatrix(double **mat,int nrows)
{
    int r;
    for ( r = 0 ; r < nrows ; r++) {
        free(mat[r]);
    }
    free(mat);
}

static inline
int
FindInternalAnglesTwins(int nrIDs, int *IDs, int *IDsPerGrain,
				   int *NrIDsPerID, bool *IDsChecked,
				   double **OPs, double *ID_IA_Mat, int counter, int Pos,
				   int StartingID, double *Radiuses, int SGNr)
{
	int i,j,k,ThisID,ThisID2;
	ID_IA_Mat[(counter*4)] = (double) StartingID;
	ID_IA_Mat[(counter*4)+1] = (double) Pos;
	ID_IA_Mat[(counter*4)+2] = OPs[Pos][IAColNr];
	ID_IA_Mat[(counter*4)+3] = Radiuses[Pos];
	IDsChecked[Pos] = true;
	counter++;
	double Angle, Axis[3],q1[4],q2[4],ang;
	double OR1[9], OR2[9];
	for (i=0;i<9;i++){
		OR1[i] = OPs[Pos][i];
	}
	OrientMat2Quat(OR1,q1);
	for (i=0;i<NrIDsPerID[Pos];i++){
		ThisID = IDsPerGrain[(Pos*NR_MAX_IDS_PER_GRAIN)+i];
		for (j=0;j<nrIDs;j++){
			ThisID2 = IDs[j];
			if (ThisID == ThisID2 && IDsChecked[j] == false){
				for (k=0;k<9;k++){
					OR2[k] = OPs[j][k];
				}
				OrientMat2Quat(OR2,q2);
				Angle = GetMisOrientation(q1,q2,Axis,&ang,SGNr);
				if (fabs(ang) < 0.1 || 
					(fabs(ang - 60) < 0.1 && 
					 fabs(Axis[0])-fabs(Axis[1]) < 0.1 && 
					 fabs(Axis[2])-fabs(Axis[1]) < 0.1)){
					counter = FindInternalAnglesTwins(nrIDs,IDs,IDsPerGrain,NrIDsPerID,IDsChecked,
							OPs,ID_IA_Mat,counter,j,ThisID,Radiuses,SGNr);
					break;
				}
			}
		}
	}
	int counte = counter;
	return counte;
}

static inline
int
FindInternalAngles(int nrIDs, int *IDs, int *IDsPerGrain,
				   int *NrIDsPerID, bool *IDsChecked,
				   double **OPs, double *ID_IA_Mat, int counter, int Pos,
				   int StartingID, double *Radiuses,int SGNr)
{
	int i,j,k,ThisID,ThisID2;
	ID_IA_Mat[(counter*4)] = (double) StartingID;
	ID_IA_Mat[(counter*4)+1] = (double) Pos;
	ID_IA_Mat[(counter*4)+2] = OPs[Pos][IAColNr];
	ID_IA_Mat[(counter*4)+3] = Radiuses[Pos];
	IDsChecked[Pos] = true;
	counter++;
	double Angle, Axis[3],q1[4],q2[4],ang;
	double OR1[9], OR2[9];
	for (i=0;i<9;i++){
		OR1[i] = OPs[Pos][i];
	}
	OrientMat2Quat(OR1,q1);
	for (i=0;i<NrIDsPerID[Pos];i++){
		ThisID = IDsPerGrain[(Pos*NR_MAX_IDS_PER_GRAIN)+i];
		for (j=0;j<nrIDs;j++){
			ThisID2 = IDs[j];
			if (ThisID == ThisID2 && IDsChecked[j] == false){
				for (k=0;k<9;k++){
					OR2[k] = OPs[j][k];
				}
				OrientMat2Quat(OR2,q2);
				Angle = GetMisOrientation(q1,q2,Axis,&ang,SGNr);
				if (fabs(ang) < 0.1){
					counter = FindInternalAngles(nrIDs,IDs,IDsPerGrain,NrIDsPerID,IDsChecked,
							OPs,ID_IA_Mat,counter,j,ThisID,Radiuses,SGNr);
					break;
				}
			}
		}
	}
	int counte = counter;
	return counte;
}

int main(int argc, char *argv[])
{
	if (argc != 4){
		printf("Usage: ProcessGrains Twins(0,1) MinNrSpots SpaceGroup\n");
		return;
	}
	clock_t start, end;
    double diftotal;
    start = clock();
    char IDsFileName[1024], BestFileName[1024], ResultFileName[1024];
    FILE *IDsFile, *BestFile, *ResultFile;
    sprintf(IDsFileName,"SpotsToIndex.csv");
    printf("Reading IDs file: %s\n",IDsFileName);
    IDsFile = fopen(IDsFileName,"r");
    char line[5024];
    int Twin = atoi(argv[1]);
	int i,j,k,ThisID,counter;
    int MinNrSpots = atoi(argv[2]);
    int SGNr = atoi(argv[3]);
    int *IDs;
    IDs = malloc(MAX_N_IDS*sizeof(*IDs));
    for (i=0;i<MAX_N_IDS;i++) IDs[i] = 0;
    int nrIDs=0;
    if (IDsFile == NULL)printf("Could not open spots file.\n");
    while (fgets(line,5024,IDsFile) != NULL){
		sscanf(line,"%d",&IDs[nrIDs]);
		nrIDs++;
	}
	fclose(IDsFile);
	printf("Total of %d IDs will be sorted into grains now.\n",nrIDs);
	bool *IDsToKeep;
	IDsToKeep = malloc(nrIDs*sizeof(*IDsToKeep));
	double *Radiuses;
	Radiuses = malloc(nrIDs*sizeof(*Radiuses));
	double *OPThis,**OPs;
	OPThis = malloc(27*sizeof(*OPThis));
	for (i=0;i<27;i++) OPThis[i] = 0;
	OPs = allocMatrix(nrIDs,23);
	int *IDsPerGrain,*NrIDsPerID;
	NrIDsPerID = malloc(nrIDs*sizeof(*NrIDsPerID));
	IDsPerGrain = malloc(NR_MAX_IDS_PER_GRAIN*nrIDs*sizeof(*IDsPerGrain));
	for (i=0;i<nrIDs;i++){
		IDsToKeep[i] = false;
		Radiuses[i] = 0;
		for (j=0;j<23;j++){
			OPs[i][j] = 0;
		}
		for (j=0;j<NR_MAX_IDS_PER_GRAIN;j++){
			IDsPerGrain[(NR_MAX_IDS_PER_GRAIN*i) + j] = 0;
		}
		NrIDsPerID[i] = 0;
	}
	FILE *fileKey = fopen("Results/Key.bin","r");
	FILE *fileOPFit = fopen("Results/OrientPosFit.bin","r");
	FILE *fileProcessKey = fopen("Results/ProcessKey.bin","r");
	if (fileKey == NULL){
		printf("Key file was not found. Exiting.\n");
		return 1;
	}
	if (fileOPFit == NULL){
		printf("OrientPos file was not found. Exiting.\n");
		return 1;
	}
	if (fileProcessKey == NULL){
		printf("ProcessKey file was not found. Exiting.\n");
		return 1;
	}
	int *keyID;
	keyID = malloc(2*sizeof(*keyID));
	size_t readKey, readOP, readProcess;
	readProcess = fread(IDsPerGrain,NR_MAX_IDS_PER_GRAIN*nrIDs*sizeof(int),1,fileProcessKey);
	for (i=0;i<nrIDs;i++){
		readKey = fread(keyID,2*sizeof(int),1,fileKey);
		if (keyID[0] == 0){
			IDsToKeep[i] = false;
			continue;
		}
		IDsToKeep[i] = true;
		NrIDsPerID[i] = keyID[1];
		readOP = fread(OPThis,27*sizeof(double),1,fileOPFit);
		counter = 0;
		for (j=0;j<27;j++){
			if (j == 0 || j == 10 || j == 14 || j == 21){
				continue;
			}
			OPs[i][counter] = OPThis[j];
			counter++;
		}
		Radiuses[i] = OPThis[25];
	}
	int StartingID,ThisID1,ThisID2;
	int nGrainPositions = 0,BestGrainPos;
	int *GrainPositions,*nGrainsMatched;
	GrainPositions = malloc(nrIDs*sizeof(*GrainPositions));
	nGrainsMatched = malloc(nrIDs*sizeof(*nGrainsMatched));
	double minIA,maxRadThis;
	printf("Read all grain files.\n");
	bool *IDsChecked;
	IDsChecked = malloc(MAX_N_IDS*sizeof(*IDsChecked));
	for (i=0;i<MAX_N_IDS;i++) IDsChecked[i] = false;
	for (i=0;i<nrIDs;i++){
		GrainPositions[i] = 0;
		nGrainsMatched[i] = 0;
		if (IDsToKeep[i] == false){
			IDsChecked[i] = true;
		}
	}
	double *ID_IA_MAT;
	double ang, Angle, Axis[3],DiffPos,OR1[9],q1[9],OR2[9],q2[4];
	int counte,counten,totcount=0;
	ID_IA_MAT = malloc(50000*4*sizeof(*ID_IA_MAT));
	for (i=0;i<50000*4;i++) ID_IA_MAT[i] = 0;
	for (i=0;i<nrIDs;i++){
		if (i%1000 == 0) printf("Processed %d of %d IDs.\n",i,nrIDs);
		if (IDsChecked[i] == false){
			counte = 0;
			StartingID = IDs[i];
			maxRadThis = Radiuses[i];
			minIA = OPs[i][IAColNr];
			if (Twin ==0){
				counten = FindInternalAngles(nrIDs,IDs,IDsPerGrain,NrIDsPerID,
				IDsChecked,OPs,ID_IA_MAT,counte,i,StartingID,Radiuses,SGNr);
			}else{
				counten = FindInternalAnglesTwins(nrIDs,IDs,IDsPerGrain,NrIDsPerID,
				IDsChecked,OPs,ID_IA_MAT,counte,i,StartingID,Radiuses,SGNr);
			}
			for (k=0;k<9;k++){
				OR1[k] = OPs[i][k];
			}
			OrientMat2Quat(OR1,q1);
			if (SGNr == 154){
				for (j=i+1;j<nrIDs;j++){
					if (IDsChecked[j] == false){
						for (k=0;k<9;k++){
							OR2[k] = OPs[j][k];
						}
						OrientMat2Quat(OR2,q2);
						Angle = GetMisOrientation(q1,q2,Axis,&ang,SGNr);
						DiffPos = sqrt((OPs[i][9]-OPs[j][9])*(OPs[i][9]-OPs[j][9]) 
									 + (OPs[i][10]-OPs[j][10])*(OPs[i][10]-OPs[j][10]) 
									 + (OPs[i][11]-OPs[j][11])*(OPs[i][11]-OPs[j][11]));
						if ((ang < 0.1 && DiffPos < 10) || (fabs(ang - 60.0) < 0.1 && 
								DiffPos < 10 && fabs(Axis[0])<0.001 && fabs(Axis[1])<0.001 && 
								fabs(fabs(Axis[2])-1)<0.001)){
							ID_IA_MAT[counten*4] = IDs[j];
							ID_IA_MAT[counten*4+1] = j;
							ID_IA_MAT[counten*4+2] = OPs[j][IAColNr];
							ID_IA_MAT[counten*4+3] = Radiuses[j];
							IDsChecked[j] = true;
							counten++;
						}
					}
				}
			}
			totcount+=counten;
			nGrainsMatched[i] = counten;
			if (counten < MinNrSpots) continue;
			for (j=0;j<counten;j++){
				if (ID_IA_MAT[(j*4)+2] < minIA){
					minIA = ID_IA_MAT[(j*4)+2];
					BestGrainPos = (int)ID_IA_MAT[(j*4)+1];
				}
				if (ID_IA_MAT[(j*4)+3] > maxRadThis){
					maxRadThis = ID_IA_MAT[(j*4)+3];
				}
			}
			GrainPositions[nGrainPositions] = BestGrainPos;
			Radiuses[BestGrainPos] = maxRadThis;
			nGrainPositions ++;
		}
	}
	
	//Write out
	int **arr;
	arr = allocMatrixInt(100000,2);
	int rowcounter = 0;
	for (i=1;i<=100000;i++){
		counten = 0;
		for (j=0;j<nrIDs;j++){
			if (nGrainsMatched[j] == i){
				counten ++;
			}
		}
		if (counten > 0){
			arr[rowcounter][0] = i;
			arr[rowcounter][1] = counten;
			rowcounter++;
		}
	}
	for (i=0;i<rowcounter;i++) printf("%d %d\n",arr[i][0],arr[i][1]);
	char GrainsFileName[1024];
	sprintf(GrainsFileName,"Grains.csv");
	FILE *GrainsFile;
	GrainsFile = fopen(GrainsFileName,"w");
	int nGrains=0;
	int *IDsDone;
	IDsDone = malloc(nGrainPositions*sizeof(*IDsDone));
	int cres=0;
	int DoneAlready = 0;
	for (i=0;i<nGrainPositions;i++){
		DoneAlready = 0;
		for (j=0;j<cres;j++){
			if (IDsDone[j] == IDs[GrainPositions[i]]){
				DoneAlready = 1;
				printf("Done already.\n");
			}
		}		
		if (DoneAlready == 1){
		 	continue;
		}else{
			IDsDone[cres] = IDs[GrainPositions[i]];
			cres++;
		}
		if (OPs[GrainPositions[i]][22] < 0.1) continue;
		fprintf(GrainsFile,"%d ",IDs[GrainPositions[i]]);
		for (j=0;j<21;j++) fprintf(GrainsFile, "%lf ", OPs[GrainPositions[i]][j]);
		fprintf(GrainsFile,"%lf %lf\n",Radiuses[GrainPositions[i]],OPs[GrainPositions[i]][22]);
		nGrains++;
	}
	printf("Number of grains: %d.\n",nGrains);
    end = clock();
	diftotal = ((double)(end-start))/CLOCKS_PER_SEC;
    printf("Time elapsed: %f s.\n",diftotal);
    return 0;
}
